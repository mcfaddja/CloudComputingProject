\documentclass{article}[12pt]
\voffset = 0.35in
\hoffset = -0.20in
\setlength{\textheight}{8.75in}
\setlength{\topmargin}{-0.0in}
\setlength{\oddsidemargin}{-0.0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.25in}
\usepackage{amsfonts, amsmath, amsthm, amssymb,mathrsfs}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{setspace}
\usepackage{layout}
\usepackage{xcolor}
\usepackage{mathtools}
\usepackage[]{algorithm2e}
\usepackage{algorithmicx}
\usepackage{multicol}
\pagestyle{fancy}
\lhead{TCSS 562 - Sp. '17}
\chead{\textbf{Comparison of NoSQL on the Cloud \\ Software, Systems and Platforms}}
\rhead{Term Project}
\headsep = 25pt 
\headheight = 15pt
%\setlength{\footskip}{-15pt}
%\marginparsep = 0in
%\marginparwidth = 0in


%\doublespacing
%\singlespacing

% BEGIN PRE-AMBLE
\usepackage{enumitem}


\usepackage[hang,bottom,flushmargin]{footmisc}

\usepackage[footnotesep=0.3in]{geometry}

%\usepackage[T1]{fontenc}

%\usepackage[flushmargin]{footmisc}

\addtolength{\footnotesep}{-0.1in} % change to 1mm

\renewcommand{\thefootnote}{\textbf{\arabic{footnote}}}




% Setup equation numbering 
\numberwithin{equation}{section} 

%Equation Numbering Shortcut Commands
\newcommand{\numbch}[1]{\setcounter{section}{#1} \setcounter{equation}{0}}
\newcommand{\numbpr}[1]{\setcounter{subsection}{#1} \setcounter{equation}{0}}
\newcommand{\note}{\textbf{NOTE:  }}

%Formatting shortcut commands
\newcommand{\chap}[1]{\begin{center}\begin{Large}\textbf{\underline{#1}}\end{Large}\end{center}}
\newcommand{\prob}[1]{\textbf{\underline{Problem #1):}}}
\newcommand{\sol}[1]{\textbf{\underline{Solution #1):}}}
\newcommand{\MMA}{\emph{Mathematica }}

%Text Shortcut Command
\newcommand{\s}[1]{\emph{Side #1}}

% Math shortcut commands
\newcommand{\dd}[2]{\frac{d #1}{d #2}}
\newcommand{\ddn}[3]{\frac{d^{#1} #2}{d #3^{#1}}}
%\newcommand{\dd}[2]{\frac{\textrm{d} #1}{\textrm{d} #2}}
%\newcommand{\ddn}[3]{\frac{\textrm{d}^{#1} #2}{\textrm{d} #3^{#1}}}
\newcommand{\pd}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\pdn}[3]{\frac{\partial^{#1} #2}{\partial #3^{#1}}}
\newcommand{\infint}{\int_{-\infty}^\infty}
\newcommand{\infiint}{\iint_{-\infty}^\infty}
\newcommand{\infiiint}{\iiint_{-\infty}^\infty}
\newcommand{\dint}[2]{\int_{#1}^{#2}}
\newcommand{\intdd}[1]{\textrm{d}#1}
\newcommand{\intddd}[1]{\textrm{d}#1}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
%\newcommand{\mat}[1]{\overleftrightarrow{\mathbf{#1}}}
%\newcommand{\mat}[1]{\bar{\bar{\mathbf{#1}}}}
\newcommand{\mat}[1]{\overline{\overline{\mathbf{#1}}}}

%Math Text
\newcommand{\rect}{\text{ rect}}
\newcommand{\csch}{\text{ csch}}

%Physics Shortcut Commands
\newcommand{\h}{\mathcal{H}}


%MRI Stuff Shortcut Commands
\newcommand{\tno}{t_{n}}
\newcommand{\tn}[1]{t_{n#1}}
\newcommand{\Mno}{\vec{M}^{\left( n \right)}}
\newcommand{\Mn}[1]{\vec{M}^{\left( n #1 \right)}}
\newcommand{\Mnto}[1]{\vec{M}^{(n)} \left( t_{n} #1 \right)}
\newcommand{\Mnt}[2]{\vec{M}^{(n #1)} \left( t_{n #1} #2 \right)}
\newcommand{\rot}[2]{\mat{R}_{#1} \left( #2 \right)}
\newcommand{\DnMat}[2]{\mat{D} \left( t_{n #1} #2 \right)}
\newcommand{\rotINV}[2]{\mat{R}^{-1}_{#1} \left( #2 \right)}
\newcommand{\DnMatINV}[2]{\mat{D}^{-1} \left( t_{n #1} #2 \right)}
\newcommand{\betaNt}[2]{\beta \left( t_{n #1} #2 \right)}
\newcommand{\TR}{\textrm{TR}}


% Math formatting commands
\newcommand{\stack}[2]{\stackrel{\mathclap{\normalfont\mbox{#1}}}{#2}}


% END PRE-AMBLE
%\renewcommand{\baselinestretch}{1.0} 
\setlength{\columnsep}{0.20in}

\begin{document}
\thispagestyle{empty}

 $\phantom{1}$ \\
 \vspace{0.2in}
 \begin{center}
 	\Huge{\textbf{\underline{Comparison of NoSQL on the Cloud}}} \\
 	\vspace{0.10in}
 	\Huge{\textbf{\underline{Software, Systems and Platforms}}} \\
 	\vspace{0.20in}
 	\begin{multicols}{3}
 		\Large{\textbf{J. McFadden}} \\
 		\vspace{0.1in} 
 		\normalsize{Univ. of Washington: Tacoma} \\ \small{Tacoma, WA} \\ 
 		\vspace{0.05in}
 		\large{\emph{mcfaddja@uw.edu}}  \\
 		
 		\Large{\textbf{Y. Tamta}} \\ 
 		\vspace{0.1in} 
 		\normalsize{Univ. of Washington: Tacoma} \\ \small{Tacoma, WA} \\ 
 		\vspace{0.05in} 
 		\large{\emph{yashaswitamta@gmail.com}} \\
 		
         		\Large{\textbf{J. N. Gandhi}} \\
 		\vspace{0.1in} 
 		\normalsize{Univ. of Washington: Tacoma} \\ \small{Tacoma, WA} \\ 
 		\vspace{0.05in} 
 		\large{\emph{jugalg@uw.edu}}
 	\end{multicols}
 	\vspace{0.3in}
 	\Large{\textbf{\underline{April 11, 2017}}} \\
 	\vspace{0.1in}
 	\small{\emph{Project coordinator indicated by \textbf{*}}}
 \end{center}
 
 
 \vspace{1.2in}




%\begin{multicols*}{2}
\begin{flushleft}


\section*{Abstract}
\begin{spacing}{1.5}
Two different NoSQL database software  packages will be implemented in and/or  installed on several different types of  systems. In turn, these systems will  be deployed on several different  platforms. This will allow different  combinations of software, systems,  and platforms to be compared based  on both performance, difficulty of setup  \& maintenance, and both setup \& operating costs.
\end{spacing}




%-----------------------------------
%-----------------------------------



\section{Introduction}
\begin{spacing}{1.5}
	The software/systems chosen for comparison in this project are two different NoSQL database system.  These systems will be deployed/run/operated in several different ways.  These include \emph{SaaS}\footnote{\textbf{SaaS :} Software as a service.} implementations, \emph{containerized} implementations, and \emph{native installations}.  The goal of the project is to understand the performance characteristics of each deployment method \emph{\textbf{and}} to quantify the costs of each deployment method.  These costs will be calculated based on the hourly cost to operate, the initial time \& costs required for setup, and the maintenance requirement of a deployment.  Additionally, performance of the systems and deployments will be measured using the time required to carry out various database operations, under a set of several different conditions, as well as the CPU, memory, and network loads imposed by the various deployments under the same set of conditions.
\end{spacing}




%-----------------------------------
%-----------------------------------




\section{Systems and Platforms}
\begin{spacing}{1.5}
	We will be using two NoSQL database software packages.  The first software package is \textbf{DynamoDB} from Amazon Web Services (\emph{AWS}), while the second software package will be \textbf{Cassandra}, an open-source NoSQL database software package.  These software packages will be deployed using several different systems and platforms, as described below.
\end{spacing}



%--------------------------------


\subsection{Systems}
\begin{spacing}{1.5}
	This project will run the software packages on three different systems (\emph{or types of systems}).  We have chosen systems which range from hosted \emph{SaaS} through various degrees of virtualization and then all the way to non-virtualized machines.  These systems are as follows
	
	\begin{enumerate}[label=\large{\textbf{\Alph*}):}]
		\item \textbf{\emph{SaaS}}
		\item \textbf{Running inside a \emph{Docker} container}
		\item \textbf{Running on a dedicated machine}
	\end{enumerate}
	
	These four systems will be deployed using several different platforms which we will describe in the next part of this section; however, before proceeding to that, we will give a through description of each system listed above.
\end{spacing}


\subsubsection{\underline{\emph{SaaS}} (code: \textbf{A}) }
\begin{spacing}{1.5}
	In this system paradigm, a particular software package is developed and maintained with the intent of being used by a provider as selling \emph{Software as a Service}. As far as system configuration on our end (\emph{the system-administrator/developer}), paradigm only requires that we select a platform provider and collected the database data so that it can eventually be prepared for deployment.
\end{spacing}


\subsubsection{\underline{Running inside a \emph{Docker} container} (code: \textbf{B}) }
\begin{spacing}{1.5}
	For the purposes for this paper and the ensuing project, we will only use \textbf{containers} which are created using and for use in \emph{Docker}.  This choice was made because of \emph{Docker}'s ubiquity, wide availability, and the ease of access to cloud services designed for and solely dedicated to the deployment of \emph{Docker} containers.  This implementation paradigm requires that a \emph{Docker} container be created after which, the software package in question be installed into the container so that it can be run on the operating system employed in the container (\emph{the OS\footnote{\textbf{OS: } Operating System} was chosen at the time of container creation}). Once the software has been installed, any information for and/or data required by it is either loaded into the container or, in the case of data \underline{\emph{only}}, the container is "pointed at" the location of the data required by the software.  Finally, we must note that, as far as this paper and project are concerned, the use of a \emph{Docker} container as a means of implementation does not imply the use of any particular platform for running the containers, or even a deployment of the \emph{Docker} software/system itself. 
\end{spacing}


\subsubsection{\underline{Running on a dedicated machine} (code: \textbf{C}) }
\begin{spacing}{1.5}
	The third system paradigm involves acquiring and configuring a dedicated machine which can be either an actual, physical machine or a virtual machine.  In either case, the machine will have performance specifications and and run an OS appropriate for our planed use.  When setting up one of these machines, after configuration and setup of physical/virtual system, the selected OS will be installed and configured for use.  Once it has been verified that the OS has been properly installed and configured (\emph{i.e. running stably}) we will install the software selected for testing on that instance, along with any other software or system components required to run that software.  After configuring the installed software, the machine will be prepared and configured for use as a server running said software.  The final step of this paradigm is preparing the software and system combination for final deployment to the selected platform.
\end{spacing}



%---------------------------------------------------


\subsection{Platforms}
\begin{spacing}{1.5}
	We have chosen four different platforms on which to deploy our systems.  The chosen platforms span the range of cloud service paradigms from \emph{SaaS} to \emph{PaaS}\footnote{\textbf{PaaS :} Platform as a service.} to \emph{IaaS}\footnote{\textbf{IaaS :} Infrastructure as a service.}.  We list the three platforms, along with two variations on one of the platforms, below
	
	
	\begin{enumerate}[label=\large{\textbf{\arabic*}):}]
		\item \textbf{(An) AWS Software Service (}\emph{SaaS}\textbf{)}
		%\item \textbf{AWS \emph{SaaS} system(s)}
		\item \textbf{Containers (}using \emph{Docker}\textbf{) running on}
		
		\begin{enumerate}[label=\large{\textbf{\roman*}):}]
			\item \textbf{\emph{AWS's Container Service} (}\emph{PaaS}\textbf{)}
			\item \textbf{\emph{AWS EC2 VM with Docker run-time} (}\emph{hybrid-Pass/IaaS}\textbf{)}
		\end{enumerate}
		\vspace{0.025in}
		
		\item \textbf{AWS EC2 VMs running the software in Linux (}\emph{IaaS}\textbf{)}
		\item \textbf{A dedicated, non-virtualized server (}\emph{server}\textbf{)}
	\end{enumerate}
	
	
	In the next section, we list which systems will run each software package, along with a explanation why each software-system pairing was chosen.  Additionally, we will describe which platforms will be used to deploy each system and why those deployment choices were made.  Before proceeding to that, and as with our list of system, we will describe each platform thoroughly.
\end{spacing}


\subsubsection{\underline{AWS Software Service} (code: \textbf{1})}
\begin{spacing}{1.5}
	Our first platform we will use for the deployment of some systems is AWS's Software Service platform which provides various software packages which run as a service.  This means that Administrator do not have to configure and secure a server and OS on which to run the software, nor do they have to install and manage the running of the software on said server.  Instead, all a System Administrator must do is create an instance of the desired Software Service, with the configuration required for the application at hand.  Once the instance has been created, it is loaded with any information required and/or data to be used, after which it is immediately available for use by users and other clients. 
\end{spacing}


\subsubsection{\underline{Containers} (code: \textbf{2\_})}\footnote{In the code \textbf{2\_}, we use the "\_" after the 2 is a place-holder for an additional code-letter.  This is due to the fact that two different versions of and approaches to this platform (\emph{container deployment}) are going to be used.}
\begin{spacing}{1.5}
	The next platform we have chosen involves the deployment of the previously described \emph{Docker} containers.  We will use two different platforms that implement the \emph{Docker} engine which is actually responsible for running the containers.  These "\emph{Docker} Platforms" are
	
	\begin{quote}
		\begin{itemize}
			\vspace{0.05in}
			\item $\bigl[$\normalsize{\emph{\underline{AWS's Container Service} (code:} \textbf{2i}\emph{)}}$\bigr]\text{\Large{\textbf{:}}}$ In this version of the second platform, we will deploy our containers by using AWS's Container Service.  When deploying to this platform, an Administrator first creates an appropriately configured instance of the Container Service.  Upon the successful creation and launch of the Container Service instance in question, the Administrator simply uploads the container being deployed to the instance and, if a data-source external to the container is required, uploads the required data to the location specified during the creation of the container.  Once the container has been uploaded to the instance (\emph{and any required data has been uploaded to the appropriate location}), the Administrator tests the instance to ensure it is functioning as expected.  In the last step, the Administrator configures the instance to properly connect with users and/or clients before finally granting them access to the deployed container. 
			\vspace{0.075in}
			\item $\bigl[$\normalsize{\emph{\underline{AWS EC2 VM with Docker run-time} (code:} \textbf{2ii}\emph{)}}$\bigr] \text{\Large{\textbf{:}}}$ The other version of the second deployment platform involves deploying our containers using a \emph{Docker} run-time/engine running in a Linux machine being hosted on AWS's EC2 Virtualization Platform.  To deploy via this platform, an Administrator begins by creating an EC2 VM instance with performance characteristics necessary for running the container inside the Linux version of \emph{Docker} run-time.  Once the EC2 VM instance has been created and successfully launched, the Administrator will install and configure an appropriate version of Linux, followed by installing the \emph{Docker} run-time and any required support software (\emph{such as software for accessing remotely stored data}).  After configuring the installation of the \emph{Docker} run-time (\emph{and any support software}), the Administrator will upload the container using \emph{Docker}.  Additionally, if a data-source external to the container is employed, up to two additional steps are required and based on whether the data is local or remote to the VM instance.  In the case the data-source is local to the VM instance, the Administrator must also configure appropriate storage on the instance, including installing and configuring any necessary software, after which the required data is uploaded to the storage location.  Similarly, if the data-source is external to the VM instance, the Administrator must also install and configure the software required for accessing the remote location (\emph{NFS, SAN, Samba, EBS, etc}), followed by configuring the system to access the remote location and the data stored within.  Once these steps are complete, the Administrator will be able configure the container to run on the VM instance, as well as configure the OS to allow the container to properly run.  These configurations involve ensuring that the container has access to the necessary networks, addresses, and ports and that any local and/or remote resources are both appropriately mounted to the container (\emph{container configuration}) and accessible to the container (\emph{OS configuration}).  With these configurations complete, the Administrator is able to launch the container and begin testing it to ensure it functions as expected.  Once the container has been determined to be properly functioning, the Administrator completes any configuration of the EC2 Instance, the VM itself (\emph{OS}), and the container itself which might be necessary for proper user and/or client access of the container.  This final configuration is followed, finally, by allowing users and clients to access the container.
		\end{itemize}
	\end{quote}
\end{spacing}


\subsubsection{\underline{AWS EC2 VMs running the software in Linux} (code: \textbf{3})}
\begin{spacing}{1.5}
	Our third deployment platform paradigm also relies on use of AWS's EC2 VM service; however, instead of installing using containers as in \textbf{\underline{2ii}}, this paradigm has the software to be tested natively and directly installed on a Linux OS being run on an AWS EC2 VM instance.  As with the previous paradigm involving an AWS EC2 VM the Administrator begins by creating an EC2 VM instance, launching it, and installing an appropriate version of the Linux operating system, with the only difference being the determination of necessary performance characteristics base on natively running the software, and any supporting software, in Linux.  Following the installation and configuration of the Linux OS, the Administrator will natively install and then configure the software to be tested, along with any other software required support software (\emph{i.e. remote data access}).  These installations are followed by creating and configuring any required local storage space on the instance, to include installing and configuring any software necessary for doing this.  In the case where remote storage be used instead of or in addition to local storage, the Administrator must also install and configure the software required for accessing the remote location, followed by configuring the system to access the remote location and the data stored within.  Once these data storage/access steps have been completed, the Administrator uploads the required data to the appropriate location or locations, after which they configure both the software being tested, so that it can locate these data-sources, and the OS, so the software can access both the data-sources and any required networks, services, or ports.  As before, this configuration step is followed first by testing to ensure the software is accessible and works as desired, and then by the final step, allowing users and clients to access the container.
\end{spacing}


\subsubsection{\underline{A dedicated, non-virtualized server} (code: \textbf{4})}
\begin{spacing}{1.5}
	The last deployment platform we have chosen is a dedicated, non-virtualized server.  These servers will natively run Linux as their OS and will be dedicated to running and serving the software to be tested and will be setup in a manner similar to that used for the AWS EC2 instances described in \textbf{\underline{3}}.  In fact the only differences between the setup process for these physical machines and the setup of the EC2 VMs are the elimination of the need to create and configure an EC2 VM instance and the added requirement to communicate with the administrator of the network on which the machines are to be deployed.  This second difference in the setup process arises because we do not have the same control over the network connections for these physical machines as we do with AWS VMs.
\end{spacing}











\section{Deployment}
\begin{spacing}{1.5}
The deployment strategy was developed with the goal of maximizing our ability to compare combinations of software, systems, and platforms.  Maximizing our choices for comparison was important because it allowed us to choose combinations which could be effectively measured and where our findings would have "real-world" applications and meaning.  We have structured the description of our deployment strategy using the software package being tested as the over-arching descriptor of they deployments (\emph{i.e. breaking all deployment down along the lines of which software package is a particular deployment testing}).  This allows us to simplify the entire deployment strategy into a single table for easy viewing. We begin by describing the systems on which we have decided to run \emph{DynamoDB}, which are as follows:

\begin{itemize}
	\item \textbf{\underline{AWS's DynamoDB Service}:} a \emph{SaaS} approach using AWS's DynamoDB SaaS Cloud Service.
	\item \textbf{\underline{A \emph{Docker} container on AWS's Container Service}:} a \emph{PaaS} approach using AWS's Container Cloud Service.
	\item \textbf{\underline{A \emph{Docker} container on an AWS EC2 VM}:} a \emph{hybrid-Pass/IaaS} approach using AWS's EC2 VM Cloud Service.
\end{itemize}


Continuing, we now describe the systems on which we have decided to run \emph{Cassandra}.  These systems are:

\begin{itemize}
	\item \textbf{\underline{A \emph{Docker} container on AWS's Container Service}:} a \emph{PaaS} approach using AWS's Container Cloud Service.
	\item \textbf{\underline{A \emph{Docker} container on an AWS EC2 VM}:} a \emph{hybrid-Pass/IaaS} approach using AWS's EC2 VM Cloud Service.
	\item \textbf{\underline{A native installation in Linux on an AWS EC2 VM}:} an \emph{IaaS} approach using AWS's EC2 VM Cloud Service.
\end{itemize}

Finally, we have the previously mentioned table. \newline
\end{spacing}
\end{flushleft} 
\begin{center}
	%\vspace{-0.60in}
	\vspace{-0.20in}
	\begin{spacing}{1.5}
	\begin{tabular}{c || c | c}
		\textbf{Cloud} & \textbf{\underline{DynamoDB}} & \textbf{\underline{Cassandra}} \\
		\textbf{Paradigm} & & \\
		\hline
		\hline
		 & & \\
		\textbf{\emph{SaaS}} & AWS's DynamoDB &  \\
		 & SaaS Cloud Service & \\
		\hline
		 & & \\
		\textbf{\emph{PaaS}} & \emph{Docker} container on & \emph{Docker} container on \\
		 & AWS's Container Service & AWS's Container Service \\
		\hline
		 & & \\
		\textbf{\emph{hybrid-PaaS/IaaS}} & A \emph{Docker} container on & A \emph{Docker} container on \\
		 & an AWS EC2 VM instance & an AWS EC2 VM instance \\ 
		\hline
		 & & \\
		\textbf{\emph{IaaS}} &  & Native installation in Linux on \\
		 &  & an AWS EC2 VM instance
	\end{tabular}
	
	or 
	
	
	\begin{tabular}{| c || c | c |}
		\hline
		$\begin{array}{c} \text{\textbf{\emph{Cloud}}} \\ \text{\textbf{\emph{Paradigm}}} \\\end{array}$ & \begin{tabular}{c} $\phantom{1}$ \\ \textbf{\underline{DynamoDB}} \\ $\phantom{1}$ \end{tabular} & \textbf{\underline{Cassandra}} \\
		\hline
		\hline
		\begin{tabular}{c} $\phantom{1}$ \\ \textbf{\emph{SaaS}} \\ $\phantom{1}$ \end{tabular} & $\begin{array}{c} \text{AWS's DynamoDB} \\ \text{SaaS Cloud Service} \end{array}$ &  \\
		\hline
		\begin{tabular}{c}  $\phantom{1}$ \\ \textbf{\emph{PaaS}} \\ $\phantom{1}$ \end{tabular} & $\begin{array}{c} \text{\emph{Docker} container on} \\ \text{AWS's Container Service} \end{array}$ & $\begin{array}{c} \text{\emph{Docker} container on} \\ \text{AWS's Container Service} \end{array}$ \\
		\hline
		\begin{tabular}{c}  $\phantom{1}$ \\ \textbf{\emph{hybrid-PaaS/IaaS}} \\ $\phantom{1}$ \end{tabular} & $\begin{array}{c} \text{A \emph{Docker} container on} \\ \text{an AWS EC2 VM instance} \end{array}$ & $\begin{array}{c} \text{A \emph{Docker} container on} \\ \text{an AWS EC2 VM instance} \end{array}$ \\
		\hline
		\begin{tabular}{c}  $\phantom{1}$ \\ \textbf{\emph{IaaS}} \\ $\phantom{1}$ \end{tabular} &  & $\begin{array}{c} \text{Native installation in Linux on} \\ \text{an AWS EC2 VM instance} \end{array}$ \\
		\hline
	\end{tabular}
	\end{spacing}
\end{center}
\begin{flushleft}
	
	

\section{Metrics}

\begin{spacing}{1.5}
We will evaluate each of the software/system/platform combinations based on three metrics.  The first two of these metrics are based on performance data which will use data collected during the operation of each of these combinations.  Each element of performance data will be collected based on carrying out a specific database operation, while the system is under a given load condition.  We will use several different types of database operations (\emph{i.e. insert, update, etc.}) when running these tests.  Additionally, each database operation will be run in several different ways, with each having a different level of complexity.  Finally, the third and last metric will be based on the cost to setup, run, and maintain the software, system, and platform used to create and deploy a given combination.
\end{spacing}














































%%\end{flushleft}
%\end{multicols*}












































\end{flushleft}
\end{document}
